	create new simple java project
	add selenium libs
		project-properties-External jar
		
	add package
	add empty main class

	add path driver for chrome browser hardcoded
		System.setProperty("webdriver.chrome.driver", 
		"D:/JavaProjects/selenium-java-3.3.1/chromedriver.exe");
		
		or better put driver to project root and
	add path driver for chrome browser self navigate to project root drivers folder
		System.setProperty("webdriver.chrome.driver", 
		System.getProperty("user.dir")+"/drivers/chromedriver.exe");
	
	
	add xpath extension to chrome by adding crx file to config
	
	so app starting will be like 
	public static void main(String[] args) throws InterruptedException {
		// add path driver for chrome browser self navigate to project root lib
		// folder
		System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/drivers/chromedriver.exe");

		// The main interface to use for testing, which represents an idealised
		// web browser.
		WebDriver driver = new ChromeDriver();
		
		ChromeOptions chromeOptions = new ChromeOptions();
		chromeOptions.addExtensions(new File(System.getProperty("user.dir") + "/drivers/xpath.crx"));

		DesiredCapabilities capabilities = DesiredCapabilities.chrome();
		capabilities.setCapability(ChromeOptions.CAPABILITY, chromeOptions);
		driver = new ChromeDriver(capabilities);

		// open yahoo.com
		driver.get("http://yahoo.com");

		driver.manage().window().maximize();
	
	
		To create .crx file for any extension install the extension in Google Chrome
		browser from Chrome Web Store.
		
		Access the local folder path of chrome extension and copy the complete path
		C:\Users\MYUSER\AppData\Local\Google\Chrome\User
		Data\Default\Extensions\fdmmgilgnpjigdojojpjoooidkmcomcm\0.8.4.9_0.
		
		Enable Developer mode on Chrome Extension page.
		
		Click on Pack Extension button and enter the copied local folder path of your
		desired extension in Extension Root Directory field.
		
		Click on Pack Extension button in pop up and verify the .crx file at location
		mentioned in confirmation pop up.
	
////// AutoIt ///////
	AutoIt - tool to automate windows base applications
	download AutoIt from https://www.autoitscript.com/site/autoit/downloads/
	download AutoIt Script Editor from https://www.autoitscript.com/site/autoit-script-editor/downloads/
	install both
	
	open both 
	AutoIt3_x64.exe from D:\Program Files (x86)\AutoIt3
	and SciTE.exe from D:\Program Files (x86)\AutoIt3\SciTE
	
	in script editor - SciTe
	File->New + File->Encoding UTF-8 with BOM
	
	than open needed page - http://tinypic.com
	click upload
	use AutoIt -> click FinderTool and drag it on needed elements on 
	uploading dialog window - file stroke and upload button
	to get their title, class and instance for script
	
	SciTe -> type script
	ControlFocus("Открытие","","Edit1")
	ControlSetText("Открытие","","Edit1","D:\\Users\\erik\\Desktop\\Hanzo.jpeg")
	ControlClick("Открытие","","Button1")
	
	save script
	right click on script and compile script(x64) to get exe file
	//ControlFocus() sets input focus to a given control on a window
	
	than we need to execute this exec when upload window opened	
		driver.findElement(By.xpath("//*[@id='the_file']")).click();
		Thread.sleep(5000);
		Runtime.getRuntime().exec(System.getProperty("user.dir", "/scriptAutoIt/uploadScript.exe"));
		
	and together this will be like 
		package TestScripts3;

		import java.io.IOException;
		import java.util.concurrent.TimeUnit;
		
		import org.openqa.selenium.By;
		import org.openqa.selenium.WebDriver;
		import org.openqa.selenium.WebElement;
		import org.openqa.selenium.chrome.ChromeDriver;
		
		public class UploaderTest {
		
			public static void main(String[] args) throws InterruptedException, IOException {
				System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/drivers/chromedriver.exe");
		
				WebDriver driver = new ChromeDriver();
		
				driver.get("http://tinypic.com");
				driver.manage().window().maximize();
				driver.manage().timeouts().implicitlyWait(3, TimeUnit.SECONDS);
		
				// 1st method how to upload file through upload function on the page(but
				// works not always)
				// driver.findElement(By.xpath("//*[@id='the_file']")).sendKeys(System.getProperty("user.dir")+"/scriptAutoIt/Hanzo.jpeg");
		
				// 2nd method how to upload file through upload function on the page
				// AutoIt - tool to automate windows base applications
		
				// to close add
				// Thread.sleep(5000);
				// driver.findElement(By.xpath("//*[@id='g367CB268B1094004A3689751E7AC568FFloatingBanner0']/div[1]/div[2]/div/span")).click();
		
				
				WebElement element = driver.findElement(By.xpath("//*[@id='the_file']"));
				element.click();
				element.click();
				Thread.sleep(5000);
				// write full path to *.exe file
				Runtime.getRuntime().exec("D:\\J\\workspace\\aWebDriverProject\\scriptAutoIt\\uploadScript.exe");
		
				// Every Java application has a single instance of class Runtime that
				// allows the application to interface with the environment in which the
				// application is running. The current runtime can be obtained from the
				// getRuntime() method.
				// exec() - Executes the specified string command in a separate process.
			}		
		}
		
////// TestNG /////////////

========Preprare to work
	in eclipse click help-> eclipse market place-> find-> testng
	 -> testng for eclipse-> install
	 
	create new class
	create new test by using annotation @Test and add TestNG libs to project

========@Test	
	@Test - mark a class or a method as part of the test.
	when test runs - xml file automatically created at temp
	D:\Users\erik\AppData\Local\Temp\testng-eclipse--1242689959
	
========Suite
	to create own test suite - create xml file on the root and configure
	which tests in which order to be run and what amount of 
	information to be in the output
	(verbose parameter responsible for amount of info in the output, 
	the bigger number - more info)
	
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
		<suite name="Login suite">
		  <test verbose="5" name="Login test">
		    <classes>
		      <class name="testNG_1.LoginTest"/>
		      <class name="testNG_1.SignUpTest"/>
		    </classes>
		  </test>
		</suite> 

========MultiSuite
	to create order of multiple test suites - create xml file with order
	
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
		<suite name="Functional suite">
			<suite-files>
				<suite-file path="./SuiteLogin.xml"></suite-file>
				<suite-file path="./SuitePaymentFuntionality.xml"></suite-file>
			</suite-files>
		</suite> <!-- Default suite -->
	
=======TestNG configuration annotations
	@BeforeSuite: The annotated method will be run before all tests in this
	suite have run.
	@AfterSuite: The annotated method will be run after all tests in this
	suite have run.
	@BeforeTest: The annotated method will be run before any test method
	belonging to the classes inside the <test> tag is run.
	@AfterTest: The annotated method will be run after all the test methods
	belonging to the classes inside the <test> tag have run.
	@BeforeGroups: The list of groups that this configuration method will run
	before. This method is guaranteed to run shortly before the first test
	method that belongs to any of these groups is invoked.
	@AfterGroups: The list of groups that this configuration method will run
	after. This method is guaranteed to run shortly after the last test
	method that belongs to any of these groups is invoked.
	@BeforeClass: The annotated method will be run before the first test
	method in the current class is invoked.
	@AfterClass: The annotated method will be run after all the test methods
	in the current class have been run.
	@BeforeMethod: The annotated method will be run before each test method.
	@AfterMethod: The annotated method will be run after each test method.

=======Skip test
	if needed to skip some test - just add throw new SkipException("someText")
	to test method
		@Test
		public void signUpViaFacebook() {
			System.out.println("SignUp via Facebook");
			throw new SkipException("Facebook functionality is not supported");
		}
		
=======Priority order	
	to create priority order of tests execution inside one class add (priority=value)
	to annotation @Test like 
		@Test(priority=1) 
	lower priorities will be scheduled first

=======Depends on another test	
	if we need some tests execution to be depended from successful execution of 
	some previous tests - we use depenendsOnMethods, like 
		@Test(dependsOnMethods = { "login" }) 
	or 
		@Test(priority = 2, dependsOnMethods = { "login" }) 
	dependsOnMethods - The list of methods this method depends on. There is
	no guarantee on the order on which the methods depended upon will be run,
	but you are guaranteed that all these methods will be run before the test
	method that contains this annotation is run. Furthermore, if any of these
	methods was not a SUCCESS, this test method will not be run and will be
	flagged as a SKIP. If some of these methods have been overloaded, all the
	overloaded versions will be run.
	
=======Preprepared Data	Xml
	in suite xml file we can define some preprepared value for tests, for that 
	add to the suite xml 
		<parameter name="email" value="appautomation@gmail.com"/>
	and than if we add to our test class annotation
		@Parameters("email")
	we can use value of this parameter in methods like
		@Test
	public void login(String email) {
		System.out.println("Inside login: " + email);
	}
	
=======Preprepared Data	@DataProvider
	right way to hold preprepared data for tests is
		@DataProvider
	Mark a method as supplying data for a test method. The data provider name 
	defaults to method name. The annotated method must return an Object[][] 
	where each Object[] can be assigned the parameter list of the test method. 
	The @Test method that wants to receive data from this DataProvider needs 
	to use a dataProvider name equals to the name of this annotation
		
		@Test(dataProvider = "testData")
		public void registerUser(String firstName, String lastName, String email, String password) {
			System.out.println(firstName);
			System.out.println(lastName);
			System.out.println(email);
			System.out.println(password);
		}

		@DataProvider
		public Object[][] testData() {
			Object[][] obj = new Object[3][4];
			obj[0][0] = "rahul";
			obj[0][1] = "singh";
			obj[0][2] = "ra@gmail.com";
			obj[0][3] = "123";
	
			obj[1][0] = "saurav";
			obj[1][1] = "singh";
			obj[1][2] = "test1@gmail.com";
			obj[1][3] = "12345";
	
			obj[2][0] = "vaibhav";
			obj[2][1] = "singh";
			obj[2][2] = "test@gmail.com";
			obj[2][3] = "pass123";
	
			return obj;
		}

=======Grouping tests
	to give the test distinction to mark the test is belong to pack of tests
	use grouping value in @test annotation like
		@Test(groups={"smoke","performance"}
	and now when we call to run group of "smoke" tests - this test will be run
	to run group of tests in xml add groups section with section run inside, 
	which contains condition "include" to run group of tests or 
	condition exclude - to run all tests except certain group	
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
		<suite name="grouping suite">
			<test verbose="2" name="Grouping test">
				<groups>
					<run>
						<include name="performance" />
					</run>
				</groups>
				<classes>
					<class name="testNG_2.GroupingTests" />
				</classes>
			</test>
		</suite> 

=======Fancy reports
	add XSLT processor libs - Saxon-HE-9.7.0-15 jar and SaxonLiaison jar
	An XSLTProcessor applies an XSLT stylesheet transformation to an XML 
	document to produce a new XML document as output. It has methods to load 
	the XSLT stylesheet, to manipulate <xsl:param> parameter values, and to 
	apply the transformation to documents

=======Listeners
	to  make listeners which will do some action on test execution, 
	pass or failure etc - make listener class which extends TestListenerAdapter 
	class, than inside override needed method like onTestSuccess, onTestFailure, 
	onTestSkipped etc like 
		public class Listener extends TestListenerAdapter {
		
			public void onTestSuccess(ITestResult tr) {
				System.out.println("Test passed");
			}
		
			public void onTestFailure(ITestResult tr){
				System.out.println("Test failed");
			}
		}
	
	than add listeners section to xml which responsible for suite running like
		<listeners>
			<listener class-name="testNG_3.Listener" />
		</listeners>

=======Maven

	Help-> Eclipse Market-> Find-> maven-> Maven Integration for Eclipse

	New Maven Project
	File-> New-> Other -> Maven-> Maven Project-> Next-> 
	Next-> maven-archetype-quickstart-> Next-> 
		Group Id - default package name
		Artifact Id - project name
		Version - 1-SNAPSHOT
	Finish
	add dependencies into dependencies section in pom.xml
	
	for selenium
	open pom.xml, open google, write maven selenium, copy maven selenium dependency
 		<dependency>
	        <groupId>org.seleniumhq.selenium</groupId>
	        <artifactId>selenium-java</artifactId>
	        <version>3.3.1</version>
    	</dependency> 
    
    for TestNG
	open pom.xml, open google, write maven testNG, copy maven testNG dependency
 		<dependency>
			<groupId>org.testng</groupId>
			<artifactId>testng</artifactId>
			<version>6.11</version>
		</dependency>
 	save, right click on project-> Maven-> Update Project
 	
 	right click on project-> Properties-> Java Build Path
 	if M2_REPO doesn't exist in Libraries-> Add Variable and
 	add M2_REPO variable
 	
 	right click on project-> Maven-> Maven Test
 	
=======Connect Database 
	add jdbc libs -> google mysql jdbc driver jar and add 
	com.mysql.jdbc_5.1.5 to project
	
	Database connection
		// A connection (session) with a specific database. SQL statements are
		// executed and results are returned within the context of a connection.
		Connection connection = null;

		String url = "jdbc:mysql://localhost:3306/";
		String dabaseName = "spitter";
		String user = "root";
		String password = "123456";

		try {
			// It initialize the class "com.mysql.jdbc.Driver" if found in the
			// classpath, this imply that the driver is registered in the JDBC
			// driver manager since the registration process is inside the
			// static initializer of the driver class ...
			//
			// There is another approach you can use to register a driver : is
			// to use
			// the static DriverManager.registerDriver() method.
			Class.forName("com.mysql.jdbc.Driver");

			connection = DriverManager.getConnection(url + dabaseName, user, password);

			// String sqlQuery = "select * from spitter";
			String sqlQuery = "select * from spitter order by id limit 1";

			// The object used for executing a static SQL statement and
			// returning the results it produces.
			Statement statement = connection.createStatement();

			// A table of data representing a database result set, which is
			// usually generated by executing a statement that queries the
			// database.
			ResultSet result = statement.executeQuery(sqlQuery);

			result.next();
			System.out.println(result.getString(1));
			System.out.println(result.getString(2));
			System.out.println(result.getString(3));
			System.out.println(result.getString(4));	

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			// the safe pattern in Java is to close your ResultSet, Statement,
			// and Connection (in that order) in a finally block
			// if (result != null) {
			// try {
			// result.close();
			// } catch (SQLException e) { /* ignored */}
			// }
			// if (statement != null) {
			// try {
			// statement.close();
			// } catch (SQLException e) { /* ignored */}
			// }
			if (connection != null) {
				try {
					connection.close();
				} catch (SQLException e) {
					/* ignored */}
			}
		}
		
=======Jenkins
	tool for continuous integration. In software engineering, continuous 
	integration (CI) is the practice of merging all developer working copies 
	to a shared mainline several times a day.	
	Jenkins helps to automate the non-human part of the whole software 
	development process, with now common things like continuous integration, 
	but by further empowering teams to implement the technical part of a Continuous Delivery. It is a server-based system running in a servlet container such as Apache Tomcat. 

	google= download jenkins->download weekly release
	open command prompt - cd to folder where jenkins is
	type java -jar jenkins.war
	open browser and go to localhost:8080, give jenkins password created local
	c26253e9d906487ebe33f0d9ef1d7971
	user: kgit1
	password: qwert111
	let jenkins add plugins
	in manage jenkins menu - start on windows start up can be turned on
	
	create new job -> type item name-> freestyle projeckt-> OK
	triggers -> periodically 
	0-0 20 * * 1 - means at 00 minutes 20 hours any day any month first day of the week
	build-> windows batch(command) %time%
	
=======Maven project in Jenkins
	create newItem -> choose maven project-> 
	in post-builds-> 
	choose - invoke top-level Maven targets
	in invoke top-level Maven targets-> choose version of maven which we added 
	in jenkins configuration main tools
	in target - type test
	in POM - type path to pom.xml of the project - D:\J\workspace\aWebDriverProjectMaven\pom.xml
	Save


=======Jenkins Disabling Security
		One may accidentally set up security realm / authorization in such a way that you may no longer able to reconfigure Jenkins.
		
		When this happens, you can fix this by the following steps:
		
		Stop Jenkins (the easiest way to do this is to stopthe servlet container.)
		Go to $JENKINS_HOME in the file system and find config.xml file.
		Open this file in the editor.
		Look for the <useSecurity>true</useSecurity> element in this file.
		Replace true with false
		Remove the elements authorizationStrategy and securityRealm
		Start Jenkins
		When Jenkins comes back, it will be in an unsecured mode where everyone gets full access to the system.
		If this is still not working, trying renaming or deleting config.xml.


=======Excel - Own lib to read excel files
	
	add lib to connect to excel-> google java excel poi jar download, 
	download from Apache POI - the Java API for Microsoft Documents
	Download-> Last stable release-> poi-bin-3.15-20160924.zip-> extract
	
	add libs from poi root to project: poi-scratchpad-3.15, poi-3.15, poi-examples-3.15, 
	poi-excelant-3.15, poi-ooxml-3.15, poi-ooxml-schemas-3.15, 
	add libs from poi folder lib: log4j-1.2.17, commons-codec-1.10, commons-collections4-4.1, commons-logging-1.2,junit-4.12.
	
	add xml beans lib
	
	XMLBeans is a technology for accessing XML by binding it to Java types. 
	XMLBeans provides several ways to get at the XML, including:
	Through XML schema that has been compiled to generate Java types that 
	represent schema types. In this way, you can access instances of the schema 
	through JavaBeans-style accessors after the fashion of "getFoo" and "setFoo".
	The XMLBeans API also allows you to reflect into the XML schema itself 
	through an XML Schema Object model.
	A cursor model through which you can traverse the full XML infoset.
	Support for XML DOM.

	add folder testData to root, add testData.xlsx to this folder
	
	new package lib, new class ExcelReader
		package lib;
	
		import java.io.FileInputStream;
		import java.io.FileNotFoundException;
		import java.io.FileOutputStream;
		import java.io.IOException;
		
		import org.apache.poi.xssf.usermodel.XSSFCell;
		import org.apache.poi.xssf.usermodel.XSSFRow;
		import org.apache.poi.xssf.usermodel.XSSFSheet;
		import org.apache.poi.xssf.usermodel.XSSFWorkbook;
		
		public class ExcelReader {
			// FileInputStream obtains input bytes from a file in a file system
			private FileInputStream inputStream = null;
		
			// A file output stream is an output stream for writing data to a File or to
			// a FileDescriptor
			private FileOutputStream outputStream = null;
		
			// object for excel file
			private XSSFWorkbook workbook = null;
		
			// object for excel file's sheet
			private XSSFSheet sheet = null;
		
			// object for excel file's sheet's row
			private XSSFRow row = null;
		
			// object for excel file's sheet's row's cell
			private XSSFCell cell = null;
		
			// path to file
			private String path = null;
		
			// constructor
			public ExcelReader() throws IOException {
				// path
				// path = System.getProperty("user.dir") + "\\testData\\testData.xlsx";
				path = "D:\\J\\workspace\\aWebDriverProject\\testData\\testData.xlsx";
		
				// stream from file
				inputStream = new FileInputStream(path);
		
				// workbook
				workbook = new XSSFWorkbook(inputStream);
		
				// first sheet of workbook
				sheet = workbook.getSheetAt(0);
			}
		
			// method gets sheetName and provides number of rows on the sheet
			public int getSheetRows(String sheetName) {
				// index of the sheet in the excel file, return -1 if incorrect name
				int index = workbook.getSheetIndex(sheetName);
				// sheet from file by index of the sheet
				sheet = workbook.getSheetAt(index);
		
				// getLasRow returns index of last row and we add +1 to get count of
				// rows, because index count starts from 0
				return sheet.getLastRowNum() + 1;
			}
		
			// method gets sheetName and provides number of columns on the sheet
			public int getSheetColumns(String sheetName) {
				// index of the sheet in the excel file, return -1 if incorrect name
				int index = workbook.getSheetIndex(sheetName);
				// index of the sheet in the excel file, return -1 if incorrect name
				sheet = workbook.getSheetAt(index);
				// get first row of the sheet
				row = sheet.getRow(0);
		
				// getLastCellNumreturns index of last cell in the row and we add +1 to
				// get count of columns, because index count starts from 0
				return row.getLastCellNum() + 1;
			}
		
			// method gets sheetName, column and row number and provides value of the
			// certain cell
			public String getCellData(String sheetName, int columnNumber, int rowNumber) {
				// index of the sheet in the excel file, return -1 if incorrect name
				int index = workbook.getSheetIndex(sheetName);
				// index of the sheet in the excel file, return -1 if incorrect name
				sheet = workbook.getSheetAt(index);
				// get row of the sheet
				row = sheet.getRow(rowNumber);
				// get cell of the row
				cell = row.getCell(columnNumber);
		
				// return cell's string value
				return cell.getStringCellValue();
			}
		
			// method gets sheetName, column and row number and provides value of the
			// certain cell
			public String getCellData(String sheetName, String colName, int rowNumber) {
				// index of the sheet in the excel file, return -1 if incorrect name
				int index = workbook.getSheetIndex(sheetName);
				// index of the sheet in the excel file, return -1 if incorrect name
				sheet = workbook.getSheetAt(index);
		
				for (int i = 0; i < getSheetColumns(sheetName); i++) {
					// get row of the sheet
					row = sheet.getRow(0);
					// get cell of the row
					cell = row.getCell(i);
					if (cell.getStringCellValue().equals(colName)) {
						row = sheet.getRow(rowNumber);
						cell = row.getCell(i);
						return cell.getStringCellValue();
					}
				}
				return null;
			}
		
			public void setCellData(String sheetName, String newData, int columnNumber, int rowNumber) {
				// index of the sheet in the excel file, return -1 if incorrect name
				int index = workbook.getSheetIndex(sheetName);
				// index of the sheet in the excel file, return -1 if incorrect name
				sheet = workbook.getSheetAt(index);
				// get row of the sheet
				row = sheet.getRow(rowNumber);
				System.out.println("workbook: " + workbook);
				System.out.println("sheet: " + sheet);
				System.out.println("row: " + rowNumber);
				System.out.println("row: " + row);
				// create cell object of the row
				cell = row.createCell(columnNumber);
				// set value to cell object
				cell.setCellValue(newData);
		
				try {
					// Creates a file output stream to write to the file with the
					// specified name
					outputStream = new FileOutputStream(path);
					// write data stream to excel file
					workbook.write(outputStream);
					// close stream
					outputStream.close();
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		
			public static void main(String[] args) throws IOException {
				ExcelReader reader = new ExcelReader();
				// System.out.println("LoginTest rows " +
				// reader.getSheetRows("LoginTest"));
				// System.out.println("SignInTest rows " +
				// reader.getSheetRows("SignUpTest"));
				//
				// System.out.println("LoginTest columns " +
				// reader.getSheetColumns("LoginTest"));
				// System.out.println("SignUpTest columns " +
				// reader.getSheetColumns("LoginTest"));
				//
				// System.out.println("Cell 0 1: " + reader.getCellData("LoginTest", 0,
				// 1));
				// System.out.println("Cell 1 1: " + reader.getCellData("LoginTest", 1,
				// 1));
				//
				// System.out.println(reader.getCellData("LoginTest", "password", 2));
				// System.out.println(reader.getCellData("SignUpTest", "firstname", 1));
		
				reader.setCellData("LoginTest", "newLogin1", 0, 2);
				reader.setCellData("LoginTest", "newPassword1", 1, 2);
		
			}
		
		}
		
=======Properties File
	create new File for properties - put in dir with test data
	fill it with data pairs
		name=vaibhav
		url=http://google.com
		browser=mozilla
		version=4.1
			
	use this properties in some test
		
		package testNG_propertiesFile;

		import java.io.FileInputStream;
		import java.io.IOException;
		import java.util.Properties;
		
		import org.testng.annotations.Test;
		
		public class LearningProperty {
		
			// The Properties class represents a persistent set of properties. The
			// Properties can be saved to a stream or loaded from a stream. Each key and
			// its corresponding value in the property list is a string.
			Properties properties;
		
			@Test
			public void testProperties() throws IOException {
				// create stream to file with properties
				FileInputStream inStream = new FileInputStream(System.getProperty("user.dir") + "/testData/config.properties");
				// initialize properties object
				properties = new Properties();
				// load properties object with data from stream
				properties.load(inStream);
		
				System.out.println(properties.getProperty("name"));
				System.out.println(properties.getProperty("url"));
				System.out.println(properties.getProperty("browser"));
				System.out.println(properties.getProperty("version"));
			}
		}
		

=======Log4j
	add log4j lib
	
	at src - create new file - log4j.properties
		#Application Logs 
		# #Here debug is the Logger level and file is used as an identifier. 
		# "devpinoyLogger" string will be passed to getLogger method of Logger class
		log4j.logger.devpinoyLogger=DEBUG, dest1 
		log4j.appender.dest1=org.apache.log4j.RollingFileAppender 		
		# "maxFileSize" is used to configure the maximum size of the log file. 
		# When file reaches this size, a new file will be created with the same name 
		# and the old file name will be add as an Index to it.
		log4j.appender.dest1.maxFileSize=5000KB 	
		# "maxBackupIndex" is used to configure maximum number of files to be backup
		log4j.appender.dest1.maxBackupIndex=3		
		# "layout" is used to set the format of the log file
		log4j.appender.dest1.layout=org.apache.log4j.PatternLayout		
		log4j.appender.dest1.layout.ConversionPattern=%d{dd/MM/yyyy HH:mm:ss} %c %m%n		 
		# "File" is used to give file name in which logs will be saved
		log4j.appender.dest1.File=D:\\J\\Logs.log 
		# do not append the old file. Create a new log file everytime 
		log4j.appender.dest1.Append=false 
		
		add Logger object to class
			Logger logger
		add System property to class
			System.setProperty("org.apache.commons.logging.Log", 
			"org.apache.commons.logging.impl.Jdk14Logger");
		initialize logger with properties
			logger = Logger.getLogger("devpinoyLogger");
		use logger to log messages(strings) to file from properties
			logger.debug("Starting of Selenium tests");


=======Saucelabs.com

	create trial account on saucelabs.com
	in user settings take access key and with  RemoteWebDriver object run test 
	on remote vm's in cloud
	
	use DesiredCapabilities to define setting of vm - operating system 
	and browser and give it with connection url to remoteWebDriver object

		import java.net.MalformedURLException;
		import java.net.URL;
		import java.util.Arrays;
		import java.util.concurrent.TimeUnit;
		
		import org.openqa.selenium.By;
		import org.openqa.selenium.Platform;
		import org.openqa.selenium.WebDriver;
		import org.openqa.selenium.chrome.ChromeDriver;
		import org.openqa.selenium.chrome.ChromeOptions;
		import org.openqa.selenium.edge.EdgeDriver;
		import org.openqa.selenium.remote.DesiredCapabilities;
		import org.openqa.selenium.remote.RemoteWebDriver;
		import org.testng.annotations.Test;
		
		public class BasicTestChrome {
		
			public static final String USERNAME = "alexandrivanov1983";
			public static final String ACCESS_KEY = "ff243ca9-1906-4a4d-8251-814a0fc5b1b4";
			public static final String URL = "https://" + USERNAME + ":" + ACCESS_KEY + "@ondemand.saucelabs.com:443/wd/hub";
		
			WebDriver driver;
		
			@Test
			public void loginTest() throws MalformedURLException, InterruptedException {
				System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/drivers/chromedriver.exe");
		
				// Class to manage options specific to ChromeDriver.
				ChromeOptions options = new ChromeOptions();
				// add argument to disable extensions
				options.addArguments("chrome.switches", "--disable-extensions");
				// options.addArguments("--disable-extensions");
		
				// DesiredCapabilities help to set properties for the WebDriver
				// Capabilities: Describes a series of key/value pairs that encapsulate
				// aspects of a browser
				DesiredCapabilities caps = DesiredCapabilities.chrome();
				caps.setCapability("platform", "Windows 10");
				caps.setCapability("version", "56.0");
				// adds options from Chrome Options to capabilities
				// one of this must disable chrome extensions, but not working on
				// saucelabs
				// caps.setCapability(ChromeOptions.CAPABILITY, options);
				// caps.setCapability("chrome.switches",
				// Arrays.asList("--disable-extensions"));
		
				WebDriver driver = new RemoteWebDriver(new URL(URL), caps);
		
				Thread.sleep(5000);
		
				// driver = new ChromeDriver();
				// driver = new ChromeDriver(options);
				driver.get("http://rediff.com");
				driver.manage().window().maximize();
				driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);
		
				driver.findElement(By.xpath("//*[@id='signin_info']/a[1]")).click();
				driver.quit();
			}
		}

=======TestNG parallel execution

	to make tests running parallel = add attribute "parallel" with value -
	"methods" to test suite xml	and attribute "thread-count" to define how 
	many threads will be going parallel
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" >
		<suite name="SmokeTest" parallel="methods" thread-count="2">
			<test name="Parallel Tests">
				<classes>
					<class name="testNG_parallelExecution.TestWebSite" />
				</classes>
			</test>
		</suite>
		
	than if using shared WebDriver object for all tests - use ThreadLocal object
	to obtain local copy of one driver for every test's thread
	first create ThreadLocal object generic to WebDriver
		public static ThreadLocal<WebDriver> dr = new ThreadLocal<>();
		
	that create webDriver which must be copied
		System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/drivers/chromedriver.exe");
		WebDriver driver = new ChromeDriver();

	than assign this web driver to threadlocal object by set() method
		setWebDriver(driver);
	
	than get back copy of that driver from threadlocal by get() method and work
	with it as usual
		dr.get().manage().window().maximize();
		dr.get().manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);
		dr.get().close();
	
	so in the end we have class like this
		import java.util.concurrent.TimeUnit;
		import org.openqa.selenium.WebDriver;
		import org.openqa.selenium.chrome.ChromeDriver;
		import org.testng.annotations.AfterMethod;
		import org.testng.annotations.BeforeMethod;
		
		public class SeleniumInitialization {
			// This class provides thread-local variables. These variables differ from
			// their normal counterparts in that each thread that accesses one (via its
			// get or set method) has its own, independently initialized copy of the
			// variable. ThreadLocal instances are typically private static fields in
			// classes that wish to associate state with a thread (e.g., a user ID or
			// Transaction ID).
			// with threadlocal we get local copy of webDriver for every thread
			// to do this use set() method of ThreadLocal which returns threadlocal copy
			// of given variable
			public static ThreadLocal<WebDriver> dr = new ThreadLocal<>();
		
			@BeforeMethod
			public void beforeMethod() {
				System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/drivers/chromedriver.exe");
		
				// create webDriver
				WebDriver driver = new ChromeDriver();
		
				// give to thread-local to get back copy of it
				setWebDriver(driver);
		
				// with get method we get local copy of object given to thread local -
				// in our case - we get WebDriver
				getWebDriver().manage().window().maximize();
				getWebDriver().manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);
			}
		
			@AfterMethod
			public void afterMethod() {
				getWebDriver().close();
			}
		
			public WebDriver getWebDriver() {
				return dr.get();
			}
		
			// method to set variable which be copied by thread-local
			public void setWebDriver(WebDriver driver) {
				dr.set(driver);
			}
		}

	and test class like
		import org.openqa.selenium.By;
		import org.testng.annotations.Test;
		
		public class TestWebSite extends SeleniumInitialization {
		
			@Test
			public void test_01() throws InterruptedException {
				getWebDriver().get("http://w3schools.com");
				Thread.sleep(5000);
				getWebDriver().findElement(By.xpath("//*[@id='mySidenav']/a[2]")).click();
				Thread.sleep(5000);
				getWebDriver().findElement(By.xpath("//*[@id='topnav']/div/ul/li[3]/a")).click();
				Thread.sleep(5000);
			}
		
			@Test
			public void test_02() throws InterruptedException {
				getWebDriver().get("http://w3schools.com");
				Thread.sleep(5000);
				getWebDriver().findElement(By.xpath("//*[@id='mySidenav']/a[2]")).click();
				Thread.sleep(5000);
				getWebDriver().findElement(By.xpath("//*[@id='topnav']/div/ul/li[3]/a")).click();
				Thread.sleep(5000);
			}		
		}
		

=======Git
	to take changes from git server -> fetch-> synchronize-> pull
	
	
	Move cursor
		1. 
		JavascriptExecutor js = (JavascriptExecutor) driver;
		        StringBuilder stringBuilder = new StringBuilder();
		        stringBuilder.append("var x = $('#NavHeader1_tabs_ctl00_btnNavHeaderTab');");
		        stringBuilder.append("x.click();");
		        js.executeScript(stringBuilder.toString());	
		
		2. 		
		WebDriver driver = new FirefoxDriver();
		JavascriptExecutor jse = (JavascriptExecutor)driver;
		jse.executeScript("document.getElementById('gbqfb').click();");
		
		
		
		3.		
		public static void mouseClickByLocator( String cssLocator ) {
		     String locator = cssLocator;
		     WebElement el = driver.findElement( By.cssSelector( locator ) );
		     Actions builder = new Actions(driver);
		     builder.moveToElement( el ).click( el );
		     builder.perform();
		}
		
		
		4.
		WebElement baseElement = driver.findElement(By.id("foo"));
		Actions clicker = new Actions(driver);
		clicker.moveToElement(baseElement).moveByOffset(X, Y).click().perform();
		
		
		5.		
		public void clickAt(IWebDriver IWebDriver1,IWebElement WebElem, int x, int y)
		        {
		            New Action(IWebDriver1)
		             .MoveToElement(WebElem, 0,0)
		             .movebyOffSet(x,y)
		             .click()
		             .build()
		             .perform();
		
		        }
		
		
		6.
		new Actions(driver).moveToElement(
		   canvas, xWithinCanvas, yWithinCanvas).perform();
		
		driver.executeScript("$('#diagramCanvas').click();");
		
		
		7.		
		Actions actionBuilder=new Actions(driver);         
		Action drawOnCanvas=actionBuilder
		                .contextClick(wbCanvas)
		                .moveToElement(wbCanvas,8,8)
		                .clickAndHold(wbCanvas)
		                .moveByOffset(120, 120)
		                .moveByOffset(60,70)
		                .moveByOffset(-140,-140)
		                .release(wbCanvas)
		                .build();
		drawOnCanvas.perform();
		
		
		8.		
		org.openqa.selenium.Point coordinates =driver.findElement(By.xpath("//canvas")).getLocation();
		System.out.println("Co-ordinates"+coordinates); 
		Robot robot = new Robot();
		robot.mouseMove(coordinates.getX(),coordinates.getY()); 
		robot.mousePress( InputEvent.BUTTON1_DOWN_MASK);
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
	
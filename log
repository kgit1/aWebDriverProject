	create new simple java project
	add selenium libs
		project-properties-External jar
		
	add package
	add empty main class

	add path driver for chrome browser hardcoded
		System.setProperty("webdriver.chrome.driver", 
		"D:/JavaProjects/selenium-java-3.3.1/chromedriver.exe");
		
		or better put driver to project root and
	add path driver for chrome browser self navigate to project root drivers folder
		System.setProperty("webdriver.chrome.driver", 
		System.getProperty("user.dir")+"/drivers/chromedriver.exe");
	
	
	add xpath extension to chrome by adding crx file to config
	
	so app starting will be like 
	public static void main(String[] args) throws InterruptedException {
		// add path driver for chrome browser self navigate to project root lib
		// folder
		System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/drivers/chromedriver.exe");

		// The main interface to use for testing, which represents an idealised
		// web browser.
		WebDriver driver = new ChromeDriver();
		
		ChromeOptions chromeOptions = new ChromeOptions();
		chromeOptions.addExtensions(new File(System.getProperty("user.dir") + "/drivers/xpath.crx"));

		DesiredCapabilities capabilities = DesiredCapabilities.chrome();
		capabilities.setCapability(ChromeOptions.CAPABILITY, chromeOptions);
		driver = new ChromeDriver(capabilities);

		// open yahoo.com
		driver.get("http://yahoo.com");

		driver.manage().window().maximize();
	
	
		To create .crx file for any extension install the extension in Google Chrome
		browser from Chrome Web Store.
		
		Access the local folder path of chrome extension and copy the complete path
		C:\Users\MYUSER\AppData\Local\Google\Chrome\User
		Data\Default\Extensions\fdmmgilgnpjigdojojpjoooidkmcomcm\0.8.4.9_0.
		
		Enable Developer mode on Chrome Extension page.
		
		Click on Pack Extension button and enter the copied local folder path of your
		desired extension in Extension Root Directory field.
		
		Click on Pack Extension button in pop up and verify the .crx file at location
		mentioned in confirmation pop up.
	
////// AutoIt ///////
	AutoIt - tool to automate windows base applications
	download AutoIt from https://www.autoitscript.com/site/autoit/downloads/
	download AutoIt Script Editor from https://www.autoitscript.com/site/autoit-script-editor/downloads/
	install both
	
	open both 
	AutoIt3_x64.exe from D:\Program Files (x86)\AutoIt3
	and SciTE.exe from D:\Program Files (x86)\AutoIt3\SciTE
	
	in script editor - SciTe
	File->New + File->Encoding UTF-8 with BOM
	
	than open needed page - http://tinypic.com
	click upload
	use AutoIt -> click FinderTool and drag it on needed elements on 
	uploading dialog window - file stroke and upload button
	to get their title, class and instance for script
	
	SciTe -> type script
	ControlFocus("Открытие","","Edit1")
	ControlSetText("Открытие","","Edit1","D:\\Users\\erik\\Desktop\\Hanzo.jpeg")
	ControlClick("Открытие","","Button1")
	
	save script
	right click on script and compile script(x64) to get exe file
	//ControlFocus() sets input focus to a given control on a window
	
	than we need to execute this exec when upload window opened	
		driver.findElement(By.xpath("//*[@id='the_file']")).click();
		Thread.sleep(5000);
		Runtime.getRuntime().exec(System.getProperty("user.dir", "/scriptAutoIt/uploadScript.exe"));
		
	and together this will be like 
		package TestScripts3;

		import java.io.IOException;
		import java.util.concurrent.TimeUnit;
		
		import org.openqa.selenium.By;
		import org.openqa.selenium.WebDriver;
		import org.openqa.selenium.WebElement;
		import org.openqa.selenium.chrome.ChromeDriver;
		
		public class UploaderTest {
		
			public static void main(String[] args) throws InterruptedException, IOException {
				System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/drivers/chromedriver.exe");
		
				WebDriver driver = new ChromeDriver();
		
				driver.get("http://tinypic.com");
				driver.manage().window().maximize();
				driver.manage().timeouts().implicitlyWait(3, TimeUnit.SECONDS);
		
				// 1st method how to upload file through upload function on the page(but
				// works not always)
				// driver.findElement(By.xpath("//*[@id='the_file']")).sendKeys(System.getProperty("user.dir")+"/scriptAutoIt/Hanzo.jpeg");
		
				// 2nd method how to upload file through upload function on the page
				// AutoIt - tool to automate windows base applications
		
				// to close add
				// Thread.sleep(5000);
				// driver.findElement(By.xpath("//*[@id='g367CB268B1094004A3689751E7AC568FFloatingBanner0']/div[1]/div[2]/div/span")).click();
		
				
				WebElement element = driver.findElement(By.xpath("//*[@id='the_file']"));
				element.click();
				element.click();
				Thread.sleep(5000);
				// write full path to *.exe file
				Runtime.getRuntime().exec("D:\\J\\workspace\\aWebDriverProject\\scriptAutoIt\\uploadScript.exe");
		
				// Every Java application has a single instance of class Runtime that
				// allows the application to interface with the environment in which the
				// application is running. The current runtime can be obtained from the
				// getRuntime() method.
				// exec() - Executes the specified string command in a separate process.
			}		
		}
		
////// TestNG /////////////

========Preprare to work
	in eclipse click help-> eclipse market place-> find-> testng
	 -> testng for eclipse-> install
	 
	create new class
	create new test by using annotation @Test and add TestNG libs to project

========@Test	
	@Test - mark a class or a method as part of the test.
	when test runs - xml file automatically created at temp
	D:\Users\erik\AppData\Local\Temp\testng-eclipse--1242689959
	
========Suite
	to create own test suite - create xml file on the root and configure
	which tests in which order to be run and what amount of 
	information to be in the output
	(verbose parameter responsible for amount of info in the output, 
	the bigger number - more info)
	
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
		<suite name="Login suite">
		  <test verbose="5" name="Login test">
		    <classes>
		      <class name="testNG_1.LoginTest"/>
		      <class name="testNG_1.SignUpTest"/>
		    </classes>
		  </test>
		</suite> 

========MultiSuite
	to create order of multiple test suites - create xml file with order
	
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
		<suite name="Functional suite">
			<suite-files>
				<suite-file path="./SuiteLogin.xml"></suite-file>
				<suite-file path="./SuitePaymentFuntionality.xml"></suite-file>
			</suite-files>
		</suite> <!-- Default suite -->
	
=======TestNG configuration annotations
	@BeforeSuite: The annotated method will be run before all tests in this
	suite have run.
	@AfterSuite: The annotated method will be run after all tests in this
	suite have run.
	@BeforeTest: The annotated method will be run before any test method
	belonging to the classes inside the <test> tag is run.
	@AfterTest: The annotated method will be run after all the test methods
	belonging to the classes inside the <test> tag have run.
	@BeforeGroups: The list of groups that this configuration method will run
	before. This method is guaranteed to run shortly before the first test
	method that belongs to any of these groups is invoked.
	@AfterGroups: The list of groups that this configuration method will run
	after. This method is guaranteed to run shortly after the last test
	method that belongs to any of these groups is invoked.
	@BeforeClass: The annotated method will be run before the first test
	method in the current class is invoked.
	@AfterClass: The annotated method will be run after all the test methods
	in the current class have been run.
	@BeforeMethod: The annotated method will be run before each test method.
	@AfterMethod: The annotated method will be run after each test method.

=======Skip test
	if needed to skip some test - just add throw new SkipException("someText")
	to test method
		@Test
		public void signUpViaFacebook() {
			System.out.println("SignUp via Facebook");
			throw new SkipException("Facebook functionality is not supported");
		}
		
=======Priority order	
	to create priority order of tests execution inside one class add (priority=value)
	to annotation @Test like 
		@Test(priority=1) 
	lower priorities will be scheduled first

=======Depends on another test	
	if we need some tests execution to be depended from successful execution of 
	some previous tests - we use depenendsOnMethods, like 
		@Test(dependsOnMethods = { "login" }) 
	or 
		@Test(priority = 2, dependsOnMethods = { "login" }) 
	dependsOnMethods - The list of methods this method depends on. There is
	no guarantee on the order on which the methods depended upon will be run,
	but you are guaranteed that all these methods will be run before the test
	method that contains this annotation is run. Furthermore, if any of these
	methods was not a SUCCESS, this test method will not be run and will be
	flagged as a SKIP. If some of these methods have been overloaded, all the
	overloaded versions will be run.
	
=======Preprepared Data	Xml
	in suite xml file we can define some preprepared value for tests, for that 
	add to the suite xml 
		<parameter name="email" value="appautomation@gmail.com"/>
	and than if we add to our test class annotation
		@Parameters("email")
	we can use value of this parameter in methods like
		@Test
	public void login(String email) {
		System.out.println("Inside login: " + email);
	}
	
=======Preprepared Data	@DataProvider
	right way to hold preprepared data for tests is
		@DataProvider
	Mark a method as supplying data for a test method. The data provider name 
	defaults to method name. The annotated method must return an Object[][] 
	where each Object[] can be assigned the parameter list of the test method. 
	The @Test method that wants to receive data from this DataProvider needs 
	to use a dataProvider name equals to the name of this annotation
		
		@Test(dataProvider = "testData")
		public void registerUser(String firstName, String lastName, String email, String password) {
			System.out.println(firstName);
			System.out.println(lastName);
			System.out.println(email);
			System.out.println(password);
		}

		@DataProvider
		public Object[][] testData() {
			Object[][] obj = new Object[3][4];
			obj[0][0] = "rahul";
			obj[0][1] = "singh";
			obj[0][2] = "ra@gmail.com";
			obj[0][3] = "123";
	
			obj[1][0] = "saurav";
			obj[1][1] = "singh";
			obj[1][2] = "test1@gmail.com";
			obj[1][3] = "12345";
	
			obj[2][0] = "vaibhav";
			obj[2][1] = "singh";
			obj[2][2] = "test@gmail.com";
			obj[2][3] = "pass123";
	
			return obj;
		}

=======Grouping tests
	to give the test distinction to mark the test is belong to pack of tests
	use grouping value in @test annotation like
		@Test(groups={"smoke","performance"}
	and now when we call to run group of "smoke" tests - this test will be run
	to run group of tests in xml add groups section with section run inside, 
	which contains condition "include" to run group of tests or 
	condition exclude - to run all tests except certain group	
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
		<suite name="grouping suite">
			<test verbose="2" name="Grouping test">
				<groups>
					<run>
						<include name="performance" />
					</run>
				</groups>
				<classes>
					<class name="testNG_2.GroupingTests" />
				</classes>
			</test>
		</suite> 

=======Fancy reports
	add XSLT processor libs - Saxon-HE-9.7.0-15 jar and SaxonLiaison jar
	An XSLTProcessor applies an XSLT stylesheet transformation to an XML 
	document to produce a new XML document as output. It has methods to load 
	the XSLT stylesheet, to manipulate <xsl:param> parameter values, and to 
	apply the transformation to documents

=======Listeners
	to  make listeners which will do some action on test execution, 
	pass or failure etc - make listener class which extends TestListenerAdapter 
	class, than inside override needed method like onTestSuccess, onTestFailure, 
	onTestSkipped etc like 
		public class Listener extends TestListenerAdapter {
		
			public void onTestSuccess(ITestResult tr) {
				System.out.println("Test passed");
			}
		
			public void onTestFailure(ITestResult tr){
				System.out.println("Test failed");
			}
		}
	
	than add listeners section to xml which responsible for suite running like
		<listeners>
			<listener class-name="testNG_3.Listener" />
		</listeners>









	
	